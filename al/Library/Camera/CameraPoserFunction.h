#pragma once

#include <math/seadMatrix.h>
#include <math/seadQuat.h>
#include <math/seadVector.h>

namespace sead {
class LookAtCamera;
class Projection;
}  // namespace sead

namespace al {
struct CameraObjectRequestInfo;
struct CameraStartInfo;
class CameraLimitRailKeeper;
class CameraPoser;
class IUseCollision;
class PlacementInfo;
class Projection;
}  // namespace al

namespace alCameraPoserFunction {
class CameraCollisionHitResult;

s32 getViewIndex(const al::CameraPoser* poser);
const sead::LookAtCamera& getLookAtCamera(const al::CameraPoser* poser);
const sead::Projection& getProjectionSead(const al::CameraPoser* poser);
const al::Projection* getProjection(const al::CameraPoser* poser);
const sead::Matrix44f& getProjectionMtx(const al::CameraPoser* poser);
f32 getNear(const al::CameraPoser* poser);
f32 getFar(const al::CameraPoser* poser);
f32 getAspect(const al::CameraPoser* poser);
const sead::Vector3f& getPreCameraPos(const al::CameraPoser* poser);
const sead::Vector3f& getPreLookAtPos(const al::CameraPoser* poser);
const sead::Vector3f& getPreUpDir(const al::CameraPoser* poser);
f32 getPreFovyDegree(const al::CameraPoser* poser);
f32 getPreFovyRadian(const al::CameraPoser* poser);
bool isPrePriorityDemo(const al::CameraStartInfo& startInfo);
bool isPrePriorityDemo2(const al::CameraStartInfo& startInfo);
bool isPrePriorityDemoTalk(const al::CameraStartInfo& startInfo);
bool isPrePriorityDemoAll(const al::CameraStartInfo& startInfo);
bool isPrePriorityEntranceAll(const al::CameraStartInfo& startInfo);
bool isPrePriorityPlayer(const al::CameraStartInfo& startInfo);
bool isEqualPreCameraName(const al::CameraStartInfo& startInfo, const char* cameraName);
bool isPreCameraFixAbsolute(const al::CameraStartInfo& startInfo);
bool isInvalidCollidePreCamera(const al::CameraStartInfo& startInfo);
bool isInvalidKeepPreCameraDistance(const al::CameraStartInfo& startInfo);
bool isInvalidKeepPreCameraDistanceIfNoCollide(const al::CameraStartInfo& startInfo);
bool isValidResetPreCameraPose(const al::CameraStartInfo& startInfo);
bool isValidKeepPreSelfCameraPose(const al::CameraStartInfo& startInfo);
f32 getPreCameraSwingAngleH(const al::CameraStartInfo& startInfo);
f32 getPreCameraSwingAngleV(const al::CameraStartInfo& startInfo);
f32 getPreCameraMaxSwingAngleH(const al::CameraStartInfo& startInfo);
f32 getPreCameraMaxSwingAngleV(const al::CameraStartInfo& startInfo);
bool isExistAreaAngleH(const al::CameraStartInfo& startInfo);
bool isExistAreaAngleV(const al::CameraStartInfo& startInfo);
f32 getAreaAngleH(const al::CameraStartInfo& startInfo);
f32 getAreaAngleV(const al::CameraStartInfo& startInfo);
bool isExistNextPoseByPreCamera(const al::CameraStartInfo& startInfo);
f32 getNextAngleHByPreCamera(const al::CameraStartInfo& startInfo);
f32 getNextAngleVByPreCamera(const al::CameraStartInfo& startInfo);
void calcCameraPose(sead::Quatf* pose, const al::CameraPoser* poser);
void calcLookDir(sead::Vector3f* lookDir, const al::CameraPoser* poser);
void calcCameraDir(sead::Vector3f* cameraDir, const al::CameraPoser* poser);
void calcCameraDirH(sead::Vector3f* cameraDirH, const al::CameraPoser* poser);
void calcLookDirH(sead::Vector3f* lookDirH, const al::CameraPoser* poser);
void calcSideDir(sead::Vector3f* sideDir, const al::CameraPoser* poser);
void calcPreCameraDir(sead::Vector3f* preCameraDir, const al::CameraPoser* poser);
void calcPreCameraDirH(sead::Vector3f* preCameraDirH, const al::CameraPoser* poser);
void calcPreLookDir(sead::Vector3f* preLookDir, const al::CameraPoser* poser);
void calcPreLookDirH(sead::Vector3f* preLookDirH, const al::CameraPoser* poser);
f32 calcPreCameraAngleH(const al::CameraPoser* poser);
f32 calcPreCameraAngleV(const al::CameraPoser* poser);
void setLookAtPosToTarget(al::CameraPoser* poser);
void calcTargetTrans(sead::Vector3f* targetTrans, const al::CameraPoser* poser);
void setLookAtPosToTargetAddOffset(al::CameraPoser* poser, const sead::Vector3f& offset);
void setCameraPosToTarget(al::CameraPoser* poser);
void setCameraPosToTargetAddOffset(al::CameraPoser* poser, const sead::Vector3f& offset);
void calcTargetTransWithOffset(sead::Vector3f* targetTransWithOffset, const al::CameraPoser* poser);
void calcTargetVelocity(sead::Vector3f* targetVelocity, const al::CameraPoser* poser);
void calcTargetVelocityH(sead::Vector3f* targetVelocityH, const al::CameraPoser* poser);
void calcTargetUp(sead::Vector3f* targetUp, const al::CameraPoser* poser);
f32 calcTargetSpeedV(const al::CameraPoser*);
void calcTargetPose(sead::Quatf*, const al::CameraPoser*);
void calcTargetFront(sead::Vector3f*, const al::CameraPoser*);
void calcTargetSide(sead::Vector3f*, const al::CameraPoser*);
void calcTargetGravity(sead::Vector3f*, const al::CameraPoser*);
f32 calcTargetSpeedH(const al::CameraPoser*);
f32 calcTargetJumpSpeed(const al::CameraPoser*);
f32 calcTargetFallSpeed(const al::CameraPoser*);
bool isChangeTarget(const al::CameraPoser*);
bool tryGetTargetRequestDistance(f32*, const al::CameraPoser*);
bool tryGetBossDistanceCurve(const al::CameraPoser*);
bool tryGetEquipmentDistanceCurve(const al::CameraPoser*);
bool isExistCollisionUnderTarget(const al::CameraPoser*);
const sead::Vector3f& getUnderTargetCollisionPos(const al::CameraPoser*);
const sead::Vector3f& getUnderTargetCollisionNormal(const al::CameraPoser*);
bool isExistSlopeCollisionUnderTarget(const al::CameraPoser*);
bool isExistWallCollisionUnderTarget(const al::CameraPoser*);
bool tryCalcSlopeCollisionDownFrontDirH(sead::Vector3f*, const al::CameraPoser*);
f32 getSlopeCollisionUpSpeed(const al::CameraPoser*);
f32 getSlopeCollisionDownSpeed(const al::CameraPoser*);
bool isExistSubTarget(const al::CameraPoser*);
bool checkValidTurnToSubTarget(const al::CameraPoser*);
void calcSubTargetBack(sead::Vector3f*, const al::CameraPoser*);
void calcSubTargetTrans(sead::Vector3f*, const al::CameraPoser*);
bool isChangeSubTarget(const al::CameraPoser*);
void calcSubTargetFront(sead::Vector3f*, const al::CameraPoser*);
f32 getSubTargetRequestDistance(const al::CameraPoser*);
f32 getSubTargetTurnSpeedRate1(const al::CameraPoser*);
f32 getSubTargetTurnSpeedRate2(const al::CameraPoser*);
f32 getSubTargetTurnRestartStep(const al::CameraPoser*);
bool tryCalcSubTargetTurnBrakeDistanceRate(f32*, const al::CameraPoser*);
bool isValidSubTargetTurnV(const al::CameraPoser*);
bool isValidSubTargetResetAfterTurnV(const al::CameraPoser*);
void clampAngleSubTargetTurnRangeV(f32*, const al::CameraPoser*);
void initCameraVerticalAbsorber(al::CameraPoser*);
void initCameraVerticalAbsorberNoCameraPosAbsorb(al::CameraPoser*);
f32 getCameraVerticalAbsorbPosUp(const al::CameraPoser*);
f32 getCameraVerticalAbsorbPosDown(const al::CameraPoser*);
void liberateVerticalAbsorb(al::CameraPoser*);
void stopUpdateVerticalAbsorb(al::CameraPoser*);
void stopUpdateVerticalAbsorbForSnapShotMode(al::CameraPoser*, const sead::Vector3f&);
void restartUpdateVerticalAbsorb(al::CameraPoser*);
void validateVerticalAbsorbKeepInFrame(al::CameraPoser*);
void invalidateVerticalAbsorbKeepInFrame(al::CameraPoser*);
void setVerticalAbsorbKeepInFrameScreenOffsetUp(al::CameraPoser*, f32);
void setVerticalAbsorbKeepInFrameScreenOffsetDown(al::CameraPoser*, f32);
void initCameraArrowCollider(al::CameraPoser*);
void initCameraArrowColliderWithoutThroughPassCollision(al::CameraPoser*);
void initCameraMoveLimit(al::CameraPoser*);
void initCameraAngleCtrl(al::CameraPoser*);
void initCameraAngleCtrlWithRelativeH(al::CameraPoser*);
void initCameraDefaultAngleRangeV(al::CameraPoser*, f32, f32);
void setCameraStartAngleV(al::CameraPoser*, f32);
void setCameraAngleV(al::CameraPoser*, f32);
f32 getCameraAngleH(const al::CameraPoser*);
f32 getCameraAngleV(const al::CameraPoser*);
void initAngleSwing(al::CameraPoser*);
bool isValidAngleSwing(const al::CameraPoser*);
void initCameraOffsetCtrlPreset(al::CameraPoser*);
const sead::Vector3f& getOffset(const al::CameraPoser*);
void initGyroCameraCtrl(al::CameraPoser*);
void resetGyro(al::CameraPoser*);
void calcCameraGyroPose(const al::CameraPoser*, sead::Vector3f*, sead::Vector3f*, sead::Vector3f*);
const sead::Vector3f& getGyroFront(al::CameraPoser*);
f32 getGyroAngleV(al::CameraPoser*);
f32 getGyroAngleH(al::CameraPoser*);
void setGyroLimitAngleV(al::CameraPoser*, f32, f32);
void setGyroSensitivity(al::CameraPoser*, f32, f32);
void reduceGyroSencitivity(al::CameraPoser*);
void stopUpdateGyro(al::CameraPoser*);
void restartUpdateGyro(al::CameraPoser*);
bool isStopUpdateGyro(const al::CameraPoser*);
bool isTargetCollideGround(const al::CameraPoser*);
bool isTargetInWater(const al::CameraPoser*);
bool isTargetInMoonGravity(const al::CameraPoser*);
bool isTargetClimbPole(const al::CameraPoser*);
bool isTargetGrabCeil(const al::CameraPoser*);
bool isTargetInvalidMoveByInput(const al::CameraPoser*);
bool isTargetEnableEndAfterInterpole(const al::CameraPoser*);
bool isTargetWallCatch(const al::CameraPoser*);
bool isSnapShotMode(const al::CameraPoser*);
void initSnapShotCameraCtrl(al::CameraPoser*);
void initSnapShotCameraCtrlZoomAutoReset(al::CameraPoser*);
void initSnapShotCameraCtrlZoomRollMove(al::CameraPoser*);
void validateSnapShotCameraLookAtOffset(al::CameraPoser*);
void validateSnapShotCameraZoomFovy(al::CameraPoser*);
void validateSnapShotCameraRoll(al::CameraPoser*);
void updateSnapShotCameraCtrl(al::CameraPoser*);
void startResetSnapShotCameraCtrl(al::CameraPoser*, s32);
void setSnapShotMaxZoomOutFovyDegree(al::CameraPoser*, f32);
f32 getSnapShotRollDegree(const al::CameraPoser*);
const sead::Vector3f& getSnapShotLookAtOffset(const al::CameraPoser*);
bool isOffVerticalAbsorb(const al::CameraPoser*);
void onVerticalAbsorb(al::CameraPoser*);
void offVerticalAbsorb(al::CameraPoser*);
void invalidateCameraBlur(al::CameraPoser*);
bool isRequestStopVerticalAbsorb(const al::CameraObjectRequestInfo&);
bool isRequestResetPosition(const al::CameraObjectRequestInfo&);
bool isRequestResetAngleV(const al::CameraObjectRequestInfo&);
bool isRequestDownToDefaultAngleBySpeed(const al::CameraObjectRequestInfo&);
bool isRequestUpToTargetAngleBySpeed(const al::CameraObjectRequestInfo&);
f32 getRequestTargetAngleV(const al::CameraObjectRequestInfo&);
f32 getRequestAngleSpeed(const al::CameraObjectRequestInfo&);
bool isRequestMoveDownAngleV(const al::CameraObjectRequestInfo&);
bool isRequestSetAngleV(const al::CameraObjectRequestInfo&);
f32 getRequestAngleV(const al::CameraObjectRequestInfo&);
bool isInvalidCollider(const al::CameraPoser*);
void validateCollider(al::CameraPoser*);
void invalidateCollider(al::CameraPoser*);
void validateCtrlSubjective(al::CameraPoser*);
void invalidateChangeSubjective(al::CameraPoser*);
void invalidateKeepDistanceNextCamera(al::CameraPoser*);
void invalidateKeepDistanceNextCameraIfNoCollide(al::CameraPoser*);
void invalidatePreCameraEndAfterInterpole(al::CameraPoser*);
bool isInvalidPreCameraEndAfterInterpole(const al::CameraPoser*);
bool isSceneCameraFirstCalc(const al::CameraPoser*);
bool isActiveInterpole(const al::CameraPoser*);
bool isInvalidEndEntranceCamera(const al::CameraPoser*);
bool isPause(const al::CameraPoser*);
bool checkFirstCameraCollisionArrow(sead::Vector3f*, sead::Vector3f*, const al::IUseCollision*,
                                    const sead::Vector3f&, const sead::Vector3f&);
bool checkFirstCameraCollisionArrow(CameraCollisionHitResult*, const al::IUseCollision*,
                                    const sead::Vector3f&, const sead::Vector3f&);
bool checkFirstCameraCollisionArrowOnlyCeiling(sead::Vector3f*, sead::Vector3f*,
                                               const al::IUseCollision*, const sead::Vector3f&,
                                               const sead::Vector3f&);
void checkCameraCollisionMoveSphere(sead::Vector3f*, const al::IUseCollision*,
                                    const sead::Vector3f&, const sead::Vector3f&, f32);
f32 calcZoneRotateAngleH(f32, const al::CameraPoser*);
f32 calcZoneRotateAngleH(f32, const sead::Matrix34f&);
f32 calcZoneInvRotateAngleH(f32, const sead::Matrix34f&);
void multVecZone(sead::Vector3f*, const sead::Vector3f&, const al::CameraPoser*);
void multVecInvZone(sead::Vector3f*, const sead::Vector3f&, const al::CameraPoser*);
void rotateVecZone(sead::Vector3f*, const sead::Vector3f&, const al::CameraPoser*);
bool calcOffsetCameraKeepInFrameV(sead::Vector3f*, sead::LookAtCamera*, const sead::Vector3f&,
                                  const al::CameraPoser*, f32, f32);
void makeCameraKeepInFrameV(sead::LookAtCamera*, const sead::Vector3f&, const al::CameraPoser*, f32,
                            f32);
void initCameraRail(al::CameraPoser*, const al::PlacementInfo&, const char*);
bool tryGetCameraRailArg(f32*, const al::PlacementInfo&, const char*, const char*);
const char* getCameraRailPointObjId(const al::CameraPoser*, s32);
al::CameraLimitRailKeeper* tryFindNearestLimitRailKeeper(const al::CameraPoser*,
                                                         const sead::Vector3f&);
sead::Vector2f calcCameraRotateStick(sead::Vector2f*, const al::CameraPoser*);
f32 calcCameraRotateStickH(const al::CameraPoser*);
f32 calcCameraRotateStickV(const al::CameraPoser*);
f32 calcCameraRotateStickPower(const al::CameraPoser*);
s32 getStickSensitivityLevel(const al::CameraPoser*);
f32 getStickSensitivityScale(const al::CameraPoser*);
bool isValidGyro(const al::CameraPoser*);
s32 getGyroSensitivityLevel(const al::CameraPoser*);
f32 getGyroSensitivityScale(const al::CameraPoser*);
bool isTriggerCameraResetRotate(const al::CameraPoser*);
bool isHoldCameraZoom(const al::CameraPoser*);
bool isHoldCameraSnapShotZoomIn(const al::CameraPoser*);
bool isHoldCameraSnapShotZoomOut(const al::CameraPoser*);
bool isHoldCameraSnapShotRollLeft(const al::CameraPoser*);
bool isHoldCameraSnapShotRollRight(const al::CameraPoser*);
bool tryCalcCameraSnapShotMoveStick(sead::Vector2f*, const al::CameraPoser*);
bool isPlayerTypeFlyer(const al::CameraPoser*);
bool isPlayerTypeHighSpeedMove(const al::CameraPoser*);
bool isPlayerTypeHighJump(const al::CameraPoser*);
bool isPlayerTypeNotTouchGround(const al::CameraPoser*);
bool isOnRideObj(const al::CameraPoser*);
}  // namespace alCameraPoserFunction
